// Code generated by go-bindata. DO NOT EDIT.
//  memcopy: true
//  compress: true
//  decompress: once
//  asset-dir: true
//  restore: true
// sources:
//  assets/index.gohtml

package assets

import (
	"bytes"
	"compress/flate"
	"io"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/tmthrgd/go-bindata/restore"
)

type asset struct {
	name string
	data string
	size int64

	once  sync.Once
	bytes []byte
	err   error
}

func (a *asset) Name() string {
	return a.name
}

func (a *asset) Size() int64 {
	return a.size
}

func (a *asset) Mode() os.FileMode {
	return 0
}

func (a *asset) ModTime() time.Time {
	return time.Time{}
}

func (*asset) IsDir() bool {
	return false
}

func (*asset) Sys() interface{} {
	return nil
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]*asset{
	"index.gohtml": &asset{
		name: "index.gohtml",
		data: "" +
			"\xb4\x54\x4f\x6b\xdb\x4e\x10\xbd\xfb\x53\x4c\x44\x7e\x90\x80\x25\xc5\xf9\x11\x12\x54\xd9\x97\xa6" +
			"\xa5\x85\xd2\x96\x92\x1c\x7a\x2a\xa3\xdd\x89\xb4\x78\xff\x88\xdd\x49\x62\x23\xfc\xdd\xcb\x4a\x6a" +
			"\x62\x0b\x17\x7a\x68\x57\x07\x2d\xef\xbd\x79\x3b\xab\x99\x51\x79\x72\xfb\xe5\xed\xdd\xf7\xaf\xef" +
			"\xa0\x61\xa3\x57\xb3\x32\xbe\x40\xa3\xad\x97\x09\xd9\x24\x02\x84\x72\x35\x03\x00\x28\x0d\x31\x82" +
			"\x68\xd0\x07\xe2\x65\x72\x7f\xf7\x3e\xbd\x49\x46\x8a\x15\x6b\x5a\x7d\x70\x86\x34\x56\x70\xab\x3c" +
			"\x09\x76\x7e\x5b\xe6\x03\x31\x88\xb4\xb2\x6b\xf0\xa4\x97\x49\xe0\xad\xa6\xd0\x10\x71\x02\x8d\xa7" +
			"\x87\x65\xd2\x30\xb7\xa1\xc8\xf3\x47\xdb\xae\xeb\x4c\x38\x93\x87\x96\x04\x7b\xca\x44\x08\xb9\x54" +
			"\x81\x5f\x00\xa3\x6c\x04\x93\xbf\xea\x9a\xd2\xa6\xfd\x47\xce\x4a\x38\x1b\xa6\xde\xbd\xe3\xb0\x8f" +
			"\x0b\xa1\x7b\xd9\xc7\x25\x55\x68\x35\x6e\x0b\x65\xb5\xb2\x94\x56\xda\x89\xf5\x9b\x03\xc5\xb3\x92" +
			"\xdc\x14\x8b\x8b\x8b\xff\x0e\xf1\x86\x54\xdd\xf0\x11\x82\x69\xc3\xa9\x24\xe1\x3c\xb2\x72\xb6\x00" +
			"\xeb\x2c\xc1\x89\x32\xad\xf3\x8c\x96\x5f\xd5\xbb\xd9\x6b\x5e\x45\xe3\x9e\xc8\x4f\xb2\xab\xdc\x26" +
			"\x0d\x0d\x4a\xf7\x5c\xc0\xc5\xf0\x64\x0b\x4f\x06\x7c\x5d\xe1\xd9\xcd\xf5\xfc\xe6\x6a\x7e\xb9\xb8" +
			"\x9e\x67\x97\xe7\x47\x5d\xb3\xda\x2b\xf9\x9b\x1b\x43\xe4\x0e\x33\x8f\x48\xca\x64\x5a\x8d\x4c\xa9" +
			"\x70\xfa\xd1\xd8\x50\x80\xa7\x96\x90\xcf\xfe\x9f\xc3\xe2\xc1\x9f\x4f\x42\xb0\x2d\x60\x41\xe6\x10" +
			"\x6d\x51\x4a\x65\xeb\x09\xb3\x1b\x2a\x92\x8f\x25\x29\xf3\xa1\xe5\xcb\xca\xc9\xed\x6a\x56\x4a\xf5" +
			"\x04\x42\x63\x08\xcb\x24\x26\x32\x16\xb0\xeb\xc0\xa3\xad\x09\x4e\xd5\x1c\x4e\x15\x93\x81\x62\x09" +
			"\xd9\x47\x26\x13\x60\x37\x5a\xee\x85\x0a\xf4\xbf\x42\x7b\x0a\xc7\x3e\xea\xba\x21\x3a\xbb\xff\xf6" +
			"\x09\x76\xbb\x04\x18\x2b\x65\x25\x6d\x7a\x4a\x59\x01\xa7\x6a\xc4\x7d\x1d\xc7\xee\x47\xa5\xd1\xae" +
			"\x13\xe8\x07\x6b\x2f\xfe\x33\x1a\x8a\xc2\xd5\xc1\x8d\xa7\x29\xa4\xf1\x6e\xe4\x27\xaa\xa3\xca\xfe" +
			"\x00\x68\xae\x92\xd5\xf4\x8c\x32\x97\xea\xe9\x0f\x1c\xc2\x63\x35\x98\xf4\xad\x57\x7b\xdc\xee\x79" +
			"\xdd\x52\x10\x5e\xb5\xb1\x15\x8f\x5b\x4e\xa0\x32\xc7\x71\x74\x5e\xf1\xae\x03\xb2\x32\x7e\xee\x11" +
			"\x2c\xf3\xb1\x68\xf9\xf0\x3b\xfb\x19\x00\x00\xff\xff",
		size: 1247,
	},
}

// AssetAndInfo loads and returns the asset and asset info for the
// given name. It returns an error if the asset could not be found
// or could not be loaded.
func AssetAndInfo(name string) ([]byte, os.FileInfo, error) {
	a, ok := _bindata[filepath.ToSlash(name)]
	if !ok {
		return nil, nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
	}

	a.once.Do(func() {
		fr := flate.NewReader(strings.NewReader(a.data))

		var buf bytes.Buffer
		if _, a.err = io.Copy(&buf, fr); a.err != nil {
			return
		}

		if a.err = fr.Close(); a.err == nil {
			a.bytes = buf.Bytes()
		}
	})
	if a.err != nil {
		return nil, nil, &os.PathError{Op: "read", Path: name, Err: a.err}
	}

	return a.bytes, a, nil
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	a, ok := _bindata[filepath.ToSlash(name)]
	if !ok {
		return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
	}

	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	data, _, err := AssetAndInfo(name)
	return data, err
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}

	return names
}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	return restore.Asset(dir, name, AssetAndInfo)
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	return restore.Assets(dir, name, AssetDir, AssetAndInfo)
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree

	if name != "" {
		var ok bool
		for _, p := range strings.Split(filepath.ToSlash(name), "/") {
			if node, ok = node[p]; !ok {
				return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
			}
		}
	}

	if len(node) == 0 {
		return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
	}

	rv := make([]string, 0, len(node))
	for name := range node {
		rv = append(rv, name)
	}

	return rv, nil
}

type bintree map[string]bintree

var _bintree = bintree{
	"index.gohtml": bintree{},
}
